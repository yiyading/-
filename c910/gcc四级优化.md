# gcc -O0 -O1 -O2 -O3 四级优化选项及每级分别做什么优化
更细节的优化内涵请参考：https://blog.csdn.net/zhangzq86/article/details/80840927

## 1. Gcc 编译优化简介
为了满足用户不同程度的的优化需要，gcc提供了近百种优化选项，用来对**编译时间，目标文件长度，执行效率**这个三维模型进行不同的取舍和平衡。

优化的方法不一而足，总体上将有以下几类：
> 1. 精简操作指令<br>
> 2. 尽量满足cpu的流水操作<br>
> 3. 通过对程序行为地猜测，重新调整代码的执行顺序<br>
> 4. 充分使用寄存器<br>
> 5. 对简单的调用进行展开等等<br>

想全部了解这些编译选项，并在其中挑选适合的选项进行优化，无疑像个噩梦般的过程。幸而gcc提供了从O0-O3以及Os这几种不同的优化级别供大家选择，在这些选项中，包含了大部分有效的编译优化选项，并且可以在这个基础上，对某些选项进行屏蔽或添加，从而大大降低了使用的难度，毕竟，在一定基础上进行取舍，比万事从头开始要好得多。

由于gcc不同版本手册差异比较大，以下主要以gcc-3.4.6为参考。

## 2. -O0
不做任何优化，这是默认的编译选项。

## 3. -O和-O1
对程序做部分编译优化，对于大函数,优化编译占用稍微多的时间和相当大的内存。

使用本项优化，编译器会**尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化**。

## 4. -O2
比O1更高级的选项，进行更多的优化。gcc将执行几乎所有的不包含时间和空间折中的优化。

当设置O2选项时，编译器并不进行循环打开（）loop unrolling以及函数内联。

**与O1比较而言，O2优化增加了编译时间的基础上，提高了生成代码的执行效率。**

## 5. -O3
比O2更进一步的进行优化。

## 6. -Os
主要是对程序的尺寸进行优化。打开了大部分O2优化中不会增加程序大小的优化选项，并对程序代码的大小做更深层的优化。

**通常我们不需要这种优化。**

# 优化介绍小结
O0选项不进行任何优化，在这种情况下，编译器尽量的缩短编译消耗（时间，空间），此时，debug会产出和程序预期的结果。当程序运行被断点打断，此时程序内的各种声明是独立的，我们可以任意的给变量赋值，或者在函数体内把程序计数器指到其他语句,以及从源程序中精确地获取你期待的结果。

O1优化会消耗稍多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。 

O2会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。

O3在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。 

Os主要是对代码大小的优化，我们基本不用做更多的关心。 通常各种优化都会打乱程序的结构，让调试工作变得无从着手。并且会打乱执行顺序，依赖内存操作顺序的程序需要做相关处理才能确保程序的正确性。  

# 优化代码有可能带来的问题 

## 1. 调试问题
如上面所提到的，任何级别的优化都将带来代码结构的改变。

例如：对分支的合并和消除，对公用子表达式的消除，对循环内load/store操作的替换和更改等，都将会使目标代码的执行顺序变得面目全非，导致调试信息严重不足。 

## 2. 内存操作顺序改变所带来的问题
在O2优化后，编译器会影响内存操作的执行顺序。
